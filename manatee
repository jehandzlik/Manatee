#!/usr/bin/perl -w
use strict;
use warnings;

use FindBin qw( $RealBin );

my @modules = qw(
    Getopt::Long
    Set::IntervalTree
);


#Check required perl modules installations.
for(@modules) {
    eval "use $_";
    if ($@) {
        printf "\nPlease install $_ perl module and rerun.\n\n";
        exit;
    }
}

#Software version.
my $version = '1.3';

#Path to Bowtie genome index.
my $path_to_bowtie_index;

#Path to Bowtie transcriptome index dir.
my $bowtie_trans_index_dir = "trans-index";

#Slash symbol.
my $slash = "/";

#Path to non coding annotation file.
my $annotation_file;

#Global variables.
my $NOT_SPECIFIED = 'not_specified';
my $fasta_format = "fasta";
my $fastq_format = "fastq";

#Path to coding annotation file.
my $general_annotation = $NOT_SPECIFIED;

#Path to reference genome fasta file.
my $reference_genome;

#Default bowtie alignment cores.
my $aln_cores = 1;

#Alignment mismatches.
my $mismatches = 1;

#Strand specific mode of the algorithm.
my $strand_specific = 'yes';

#Maximum value for -m parameter in bowtie execution. 
my $m = 50;

#Maximum nt distance between consecutive reads that will be considered to belong to the same cluster.
my $clust_dist = 50;

#Minimum number of reads that can comprise one read cluster.
my $clust_dens = 5;

#Path to Bowtie transcriptome index.
my $bowtie_trans_index = $NOT_SPECIFIED;

#Total number of aligned reads.
my $total_aligned_reads = 0;

#Global separor strings.
my $SEPARATOR = "SePaRaToR";

#Seperator for alternative transcripts.
my $ALTERNATIVE_TRANS_SEPARATOR = " ";
my $ALTERNATIVE_TRANS_SEPARATOR_FILE = ",";

#Global string.
my $EMPTY = '';

#Tag included in the generated SAM output file.
my $global_unaligned_tag;

#Search space for a multimapped read.
my $multimap_range = 50;

#Data structure for placement of alignment scores. 
my @range_downstream;
for (my $i = $multimap_range; $i > 0; $i--){ 
  push @range_downstream, (1/exp($i / 10));
}
my @range_upstream = reverse @range_downstream;

#Total number of mapped reads.
my $mapped_reads = 0;

#Tag for reads without existing annotation.
my $no_annotation_flag = 'no_annotation';

#Tag for uniquely aligned read. 
my $unique_type = 'unique';

#Tag for multimapped read.
my $non_unique_type = 'non_unique';

#Indicator for collapsing the input reads.
my $collapsed = 1;

#Not applicable parameter.
my $NA = 'NA';

#Number of transcripts with the highest aligner score as obtained from the alignment to the transcriptome.
my $n_best_transcripts = 3;

#The max number of reads assigned to a candidate transcript for a read in alignment against transcriptome mode.
my %transcripts_transcriptome_maxExp;

#Best scores for transcripts in alignment against transcriptome mode.
my %transcripts_transcriptome_bestScore;

#Check if program was called without any input parameters or if user asked for help.
if(!exists $ARGV[0] || $ARGV[0] =~ /-h|--h|-help|--help/){
  get_help();
  exit;
}

#Read input parameters.
my $config_file;
my $input_file;
my $output_path;

GetOptions (
  'config=s' => \$config_file,
  'i=s' => \$input_file,
  'o=s' => \$output_path,
  'index=s' => \$path_to_bowtie_index,
  'annotation=s' => \$annotation_file,
  'genome=s' => \$reference_genome,
  'cores=s' => \$aln_cores,
  'mismatches=s' => \$mismatches,
  'strand_spec=s' => \$strand_specific,
  'm=s' => \$m,
  'cdi=s' => \$clust_dist,
  'cd=s' => \$clust_dens,
  't_index=s' => \$bowtie_trans_index,
  'collapse=s' => \$collapsed
);

#Check user input for required input file.
if (not defined $input_file) {
    print "\nArgument -i/--i is mandatory. Use option -h for help message.\n\n";
    exit;
}

#Check if input file exists.
if (!-e $input_file){
    print "\nInput file must exists.\n";
    exit;
}

#Check user input for required output path.
if (not defined $output_path) {
    print "\nArgument -o/--o is mandatory. Use option -h for help message.\n\n";
    exit;
}

#Execution with configuration file.
if(defined $config_file){
  #Open the configuration file.
  open(CONFIG_FILE,"<",$config_file) or die "$0: open $config_file: $!";
  #Read the configuration file. 
  while(my $line_config=<CONFIG_FILE>){
    if($line_config !~ /^$/){
      chomp $line_config;
      my @split_line = split('=',$line_config);
      if ($split_line[0] eq "index"){
	$path_to_bowtie_index = $split_line[1];
      }elsif ($split_line[0] eq "genome"){
	$reference_genome = $split_line[1];
      }elsif ($split_line[0] eq "annotation"){
	$annotation_file = $split_line[1];
      }elsif ($split_line[0] eq "t_index" && exists $split_line[1]){
	$bowtie_trans_index = $split_line[1];
      }elsif ($split_line[0] eq "cores" && exists $split_line[1]){
        $aln_cores = $split_line[1];
      }elsif ($split_line[0] eq "m" && exists $split_line[1]){
	$m = $split_line[1];
      }elsif ($split_line[0] eq "collapse" && exists $split_line[1]){
	$collapsed = $split_line[1];
	if($split_line[1] eq "yes"){
	  $collapsed = 1;
	}elsif($split_line[1] eq "no"){
	  $collapsed = 0;
	}else{
	  print "\nCollapse mode should be defined either as yes or no (default -collapse yes).\n";
	  exit;
	}
      }elsif ($split_line[0] eq "s" && exists $split_line[1]){
	if($split_line[1] eq "yes"){
	  $strand_specific = 1;
	}elsif($split_line[1] eq "no"){
	  $strand_specific = 0;
	}else{
	  print "\nStrand specific mode should be defined either as yes or no (default -s yes).\n";
	  exit;
	}
      }
      elsif ($split_line[0] eq "cdi" && exists $split_line[1]){
	$clust_dist = $split_line[1];
      }elsif ($split_line[0] eq "cd" && exists $split_line[1]){
	$clust_dens = $split_line[1];
      }
    }
  }
}

###Check user inputs###

#Check for reference genome file.
if(!-s $reference_genome){
  print STDERR "\nFATAL: Defined genomic file does not exist. 
Add proper genome file and rerun.\n\n"; 
  exit;
}

#Check for annotation file
if(!-s $annotation_file){
  print STDERR "\nFATAL: Defined non coding annotation file does not exist. 
Add non coding annotation and rerun.\n\n"; 
  exit;
}

#Check for bowtie transcriptome index.
if(check_index($bowtie_trans_index) eq 0){
	  print "\n
FATAL: Incorrect transcriptome index files. Check your transcriptome index files and rerun.
If parameter t_index is left blank, the transcriptome index will be generated based on provided 
annotation file and placed in the trans-index directory.\n\n";
	  exit;
}

#Check for bowtie index.
if (not defined $path_to_bowtie_index) {
  print "\nFATAL: Argument -index is mandatory. You can define all the input parameters
in the configuration file and run the program with -config <file>.\n\n";
exit;
}

#Check for 
if(check_index($path_to_bowtie_index) eq 0){
print "\nFATAL: Incorrect index files. Check your genome index files and rerun.\n\n";
  exit;
}
	
if($aln_cores !~ /^[0-9]+$/ || $aln_cores <= 0){
  print "\nNumber of alignment cores needs to be a positive integer (default -cores 1).\n\n";
  exit;
}

if($clust_dens !~ /^[0-9]+$/ || $clust_dens <= 0){
  print "\nMinimum number of unannotated read abundances per cluster should 
be a positive integer (default: cd=5).\n\n";
  exit;
}

if($clust_dist !~ /^[0-9]+$/ || $clust_dist <= 0){
  print "\nDistance between clusters of unannotated reads needs to be a positive 
integer (default -cdi 200).
  
Clusters of unannotated reads will be merged if the distance between them is 
equal or less than cdi.\n\n";
  exit;
}

if($m !~ /^[0-9]+$/ || $m <= 0){
  print "\n-m needs to be a positive integer number (default -m 50).\n\n";
  exit;
}

if(!defined $config_file){
  if($strand_specific eq 'yes'){
    $strand_specific = 1;
  }elsif($strand_specific eq 'no'){
    $strand_specific = 0;
  }else{
    print "\nStrand specific mode should be defined either as yes or no (default -s yes).\n";
    exit;
  }
}

#Check the samtools installation.
my $samtools_availability = `which samtools`;
if(length($samtools_availability) == 0){
  print "FATAL: Make sure you have samtools installed and added to your path.\n";
  exit;
}

#Path to bowtie aligner.
my $path_to_bowtie = $RealBin.'/bowtie-1.0.1/bowtie';

my $path_to_bowtie_build = $RealBin.'/bowtie-1.0.1/bowtie-build';

#Check whether the bowtie file is executable
if(! -x $path_to_bowtie){
  print("\nChange the permission rights to executable for: $path_to_bowtie \n\n");
  exit;
}

#Check whether the bowtie-build file is executable
if(! -x $path_to_bowtie_build){
  print("\nChange the permission rights to executable for: $path_to_bowtie_build \n\n");
  exit;
}

#Check whether the ouput directory exists.
if (-d $output_path){
  print "\nOutput directory $output_path already exists.\n\n";
  exit;
}else{
  mkdir $output_path or die "\nThe path $output_path needs to exist.\n";
}

#Add slash to path if missing.
if(substr($output_path,-1) ne '/'){
  $output_path = $output_path.'/';
}

#Print user input.
print_user_input();

#Decompress input.
decompress();

#Check input format.
my $input_file_format = file_format($input_file);

#Struct with transcript name and related info.
my %transcript_name;

#Define non-coding annotation hash.
my %gtf;
my %gtf_simplified;
my $annotation = Set::IntervalTree->new;

#Process and store annotation to hash.
process_annotation($annotation_file);

#Define condensed reads hash, utilized for time optimization.
my %collapsed_reads = ();
my %read_tags = ();

my $input_base_name;
my $input_path;

#Extract the path and base name of the input file.
get_input_filename_base_path($input_file);

#Input reads will be condensed, optimizing both execution time and available memory usage.
my $collapsed_input = $output_path.$input_base_name."_condensed.fasta"; 

#Process input fasta or fa file. Condensed reads creation, length of input file reduced. 
if($collapsed){ 
  process_input($input_file,$collapsed_input);
  $input_file = $collapsed_input;
}

#Temp files.
my $bowtie_output = $output_path.$input_base_name.'_Manatee_bowtie.output.sam';
my $bowtie_unaligned = $output_path.$input_base_name.'_Manatee_bowtie.unaligned.fa'; 
my $reads_exceeding_m = $output_path.$input_base_name.'_Manatee_bowtie.over_m.fa';

#Constrution of bowtie call.
my $bowtie_call;
if($input_file_format eq $fasta_format){
  $bowtie_call = "$path_to_bowtie -f --quiet -v $mismatches --best --strata --all -m $m -p $aln_cores -S $path_to_bowtie_index $input_file $bowtie_output --max $reads_exceeding_m --un $bowtie_unaligned";  ## always -f because of read condensation process
}else{
  $bowtie_call = "$path_to_bowtie --quiet -v $mismatches --best --strata --all -m $m -p $aln_cores -S $path_to_bowtie_index $input_file $bowtie_output --max $reads_exceeding_m --un $bowtie_unaligned";  ## always -f because of read condensation process
}

#Call Bowtie for genome alignment.
system("$bowtie_call");

#Sort sam file based on 1st column.
`sort -T $output_path -k 1,1 $bowtie_output`;

#Structure for uniquely aligned reads.
my $uniquely_aligned_tree = Set::IntervalTree->new;
my $uniquely_aligned_count = 0;

my $tmp_sam = $output_path.$input_base_name.'Manatee_tmp.sam';
my %densities; 
my %transcripts;

my %tmp_hash;

#File with multimaps/UARs without existing annotation.
my $no_indication_file = $output_path.$input_base_name.'_Manatee_no_indication.txt';
open(my $NO_INDICATION_FILE, ">", $no_indication_file);

#Hash for isomiR storage.
my %isomirs;
my $isomir_counter = 0;

#Process mapped reads and create temp file with aligned reads and their counts.
reads_process($bowtie_output);

#Quantify reads.
quantify();

#Tmp file for alignment against transcriptome.
my $trans_unaligned_0 = $output_path.$input_base_name.'_Manatee_transcriptome_unaligned_0';

my %transcripts_transcriptome;
my %no_indication_tag;
my $trans_aligned = $output_path.$input_base_name.'_Manatee_transcriptome_aligned_0.sam';

#Alignemnt against transcriptome of reads that exceeded the -m parameter in bowtie aligment.
align_against_transcriptome($reads_exceeding_m, $trans_unaligned_0, 1, $trans_aligned); #One mismatch

$trans_aligned = $output_path.$input_base_name.'_Manatee_transcriptome_aligned_1.sam';
my $trans_unaligned_1 = $output_path.$input_base_name.'_Manatee_transcriptome_unaligned_1';

#Alignment against transcriptome of unaligned reads in bowtie alignment.
align_against_transcriptome($bowtie_unaligned, $trans_unaligned_1, 2, $trans_aligned); #Two mismatches

$trans_aligned = $output_path.$input_base_name.'_Manatee_transcriptome_aligned_2.sam';
my $trans_unaligned_prev = $trans_unaligned_1;
my $trans_unaligned_2 = $output_path.$input_base_name.'_Manatee_transcriptome_unaligned_2';

#Augmented number of mismatches.
align_against_transcriptome($trans_unaligned_prev, $trans_unaligned_2, 3, $trans_aligned);

create_no_indication_tag($no_indication_file);

#Store transcripts aligned to the transcriptome to the proper transcript structure. 
store_transcripts();

my $clusters_output = $output_path.$input_base_name.'_Manatee_clusters.tsv';
unannotated_clusters();

#Write transcripts to file.
my $transcripts_counts = $output_path.$input_base_name.'_Manatee_counts.tsv';
write_expressions();

my $isomirs_file = $output_path.$input_base_name.'_Manatee_isomirs.tsv';
write_isomirs();

#Remove all the temp files from the working directory.
clean();

print "Output directory: $output_path\n\n";

print "END OF EXECUTION\n\n";

####### SUBROUTINES #######

#Extract .gz files.
sub decompress {

  if($input_file =~ /.gz$/){
    my $gunzip_output = `gunzip -l $input_file`; # List file content.
    my @gunzip_output = split("\n", $gunzip_output);
    @gunzip_output = split(" ", $gunzip_output[1]);
    my @gunzip_name = split("/",$gunzip_output[3]);
    my $gunzip_name = $gunzip_name[$#gunzip_name];
    `gunzip -c $input_file > $output_path$gunzip_name`;   
    $input_file = $output_path.$gunzip_name;
  }
}

#Write isomirs to the output file.
sub write_isomirs {

  if(%isomirs){
    open(my $fp, ">", $isomirs_file);
    print $fp "Transcript Name\tCount\tRPM\tSequence\n";
    foreach my $trans_name (sort keys %{isomirs}){
      foreach my $sequence (keys %{$isomirs{$trans_name}}){
	
	  my $rpm = ($isomirs{$trans_name}{$sequence}*(10**6))/($mapped_reads);
	  print $fp "$trans_name\t$isomirs{$trans_name}{$sequence}\t$rpm\t$sequence\t\n";
      }
    }
  }
}

#Create file with multimaps/UARs without existing annotation.
sub create_no_indication_tag {

  my $input = shift;
  
  close($NO_INDICATION_FILE);

  open(my $fp, "<", $input);
  
  my $counter = 0;
  my $read_id;

  while (my $line = <$fp>){
  
    chomp $line;
    
    my @arr = split($SEPARATOR, $line);
    
    $read_id = $arr[0];

    $counter++;

    my $chr = $arr[1];
    my $strand = $arr[2];
    my $start = $arr[3];
    my $stop = $arr[4];

    $no_indication_tag{$read_id}{$counter} = $chr.$SEPARATOR.$strand.$SEPARATOR.$start.$SEPARATOR.$stop;
    $no_indication_tag{$read_id}{'counter'} = $counter;

    if($counter == $arr[$#arr]){
      $counter = 0;    
    }
  }
 
  close($fp);
  
}

#Store clusters from UARs without existing annotation.
sub unannotated_clusters {

  my $read_id;
  my %dens; 
  my $chr;
  my $strand;
  
  #Create uar densities.
  foreach my $read_id (keys %{no_indication_tag}){
    
    if( $no_indication_tag{$read_id}{'counter'} eq 1 ){
      
      my @arr = split($SEPARATOR, $no_indication_tag{$read_id}{1});
      $chr = $arr[0];
      $strand = $arr[1];
      my $start = $arr[2];
      my $stop = $arr[3];
     
      for (my $i=$start; $i <= $stop; $i++){

	if(exists $dens{$chr}{$strand}{$i}){
	  if($collapsed){
	    $dens{$chr}{$strand}{$i} += $read_tags{$read_id};
	  }else{
	    $dens{$chr}{$strand}{$i}++;
	  }
	}else{
	  if($collapsed){
	    $dens{$chr}{$strand}{$i} = $read_tags{$read_id};
	  }else{
	    $dens{$chr}{$strand}{$i} = 1;
	  }
	}
      }
      
    }
  }

  my %uar_clusters;
  my $clusters = Set::IntervalTree->new;
  my $prev_nc = 0;
  my $cluster_start;
  my $reads_per_cluster= 0;
  my %subclusters;
  my $counter = 0;
  my $flag;
  my $rpc;

  foreach $chr (sort keys %{dens}){
    foreach $strand (sort keys %{$dens{$chr}}){
      my $new_cluster = 1;
      $counter = 0;
      $reads_per_cluster = 0;
      $flag = 0;
      foreach my $nc (sort {$a <=> $b} keys %{$dens{$chr}{$strand}}){

        if( $flag and abs($prev_nc-$nc) > 1 and abs($prev_nc-$nc) <= $clust_dist ){
	  $subclusters{$counter} = $reads_per_cluster;
	  $counter++;
	  $reads_per_cluster = 0;
        }
        
	if( $flag and abs($prev_nc-$nc) > $clust_dist ){
	
	  $rpc = 0;
	  
	  foreach my $counter (keys %{subclusters}){
	    $rpc = $rpc + $subclusters{$counter};
	  }

	  $uar_clusters{$chr}{$strand}{$cluster_start}{$prev_nc} = $reads_per_cluster + $rpc;
	  my $uar = $reads_per_cluster + $rpc;
	  my $full_info = $chr.$SEPARATOR.$strand.$SEPARATOR.$uar;
	  
	  $clusters->insert($full_info, $cluster_start,$prev_nc);
	  
	  $new_cluster = 1;
	  $reads_per_cluster = 0;
	  %subclusters = ();
	  $counter = 0;
	  
	}
	
	if($new_cluster){
	  $cluster_start = $nc;
	  $new_cluster = 0;
	  %subclusters = ();
	  $counter = 0;
	  $reads_per_cluster = 0;
	}
	$prev_nc = $nc;
	$flag = 1;
	
	if($dens{$chr}{$strand}{$nc} > $reads_per_cluster){
	  $reads_per_cluster = $dens{$chr}{$strand}{$nc};
        }
	
      }
    }
  }
  #Store the last cluster to the hash.
  if(%{subclusters}){
  
    foreach my $counter (keys %{subclusters}){
      $rpc = $rpc + $subclusters{$counter};
    }
    
    my $uar = $reads_per_cluster + $rpc;
    my $full_info = $chr.$SEPARATOR.$strand.$SEPARATOR.$uar;
    $uar_clusters{$chr}{$strand}{$cluster_start}{$prev_nc} = $reads_per_cluster + $rpc;
  }
  
  open(my $cl, ">", $clusters_output);
  
  print $cl "Chromosome\tStrand\tStart\tStop\tCluster Length\tCount\n";
  
  my $all_cluster_count = 0;
  my $cluster_count = 0;
  foreach my $chr (sort {
    my @aa = $a =~ /^([A-Za-z]*)(\d*)/;
    my @bb = $b =~ /^([A-Za-z]*)(\d*)/;
    lc $aa[0] cmp lc $bb[0] or $aa[1] <=> $bb[1]; } keys %{uar_clusters}){
    foreach my $strand (sort keys %{$uar_clusters{$chr}}){
      foreach my $cluster_start (sort {$a <=> $b} keys %{$uar_clusters{$chr}{$strand}}) {
	foreach my $cluster_stop (sort {$a <=> $b} keys %{$uar_clusters{$chr}{$strand}{$cluster_start}}) {
	  if($uar_clusters{$chr}{$strand}{$cluster_start}{$cluster_stop} >= $clust_dens){
	    my $cluster_length = $cluster_stop - $cluster_start + 1;
	    print $cl "$chr\t$strand\t$cluster_start\t$cluster_stop\t$cluster_length\t$uar_clusters{$chr}{$strand}{$cluster_start}{$cluster_stop}\n";
	  }
	}
      }
    }
  }
}

#Alignment against transcriptome for a) reads that exceed the MaxMultiLoci parameter b) unaligned to the genome reads.
sub align_against_transcriptome {

my $input = shift; 
my $trans_unaligned = shift;
my $mismatches = shift;
my $trans_aligned = shift;
my $create_index;

  if (-e $input){
    my @files;
    my %transcripts_temp;
    my $bowtie_trans_index = check_index($bowtie_trans_index);
    if($bowtie_trans_index eq $NOT_SPECIFIED){ #Creating transcriptome index file inside the transcripts directory.
	my @path = split('/',$annotation_file);
	
	if(!-e $RealBin.$slash.$bowtie_trans_index_dir){ #Create directory trans-index
	  mkdir $RealBin.$slash.$bowtie_trans_index_dir; 
	}	

	my $transcripts_fasta = $RealBin.$slash.$bowtie_trans_index_dir.$slash.$path[$#path].'.fa';
	
	$bowtie_trans_index = $RealBin.$slash.$bowtie_trans_index_dir.$slash.$path[$#path];
	open(TRANSCRIPTS, ">", $transcripts_fasta); #Fasta file that will contain transcript sequences.
	my $start_loci;
	my $stop_loci;
	  
	foreach my $chromosome (keys %{gtf}){
	
	foreach my $strand (keys %{$gtf{$chromosome}}){
	  foreach my $start (keys %{$gtf{$chromosome}{$strand}}){
	    foreach my $stop (keys %{$gtf{$chromosome}{$strand}{$start}}){
	      my @elements = split($SEPARATOR,$gtf{$chromosome}{$strand}{$start}{$stop});
	      $transcripts_temp{$elements[2]} = $gtf{$chromosome}{$strand}{$start}{$stop}; 
	      $start_loci = $start;
	      $stop_loci = $stop;
	      my $biotype = $elements[1];
	      if($biotype eq 'miRNA'){
		$start_loci = $start-5;
		$stop_loci  = $stop+5;
	      }
	      my $output = `samtools faidx $reference_genome $chromosome:$start_loci-$stop_loci 2> /dev/null`;
	      my @array = split('\n',$output);
	      my $sequence = "";
	      my $first=0;
	      foreach my $element (@array){
		if($first){
		  $sequence=$sequence.$element;
		}
		  $first=1;
	      }
		if($sequence ne "" && $sequence !~ /N/){
		  $sequence =~ s/^\s+|\s+$//g; # Removing leading and trailing white spaces.
		  print TRANSCRIPTS ">$elements[2]\n";
		  print TRANSCRIPTS "$sequence\n";
		}
	      }
	    }
	  }
	}
      close TRANSCRIPTS;
      if(!-s $transcripts_fasta){ #Transcripts fasta is empty. 
	 `rm $transcripts_fasta`;
	 return;
      }
      	print STDERR "
Building transcriptome index ...
";
	
      `$RealBin/bowtie-1.0.1/bowtie-build --quiet $transcripts_fasta $bowtie_trans_index`; #Build transcriptome idex with bowtie.
      
       print "Created index: $bowtie_trans_index\n";
    }
      my $file_format = file_format($input);
      #Align reads that exceed MaxMultiLoci against the transcriptome
      if($file_format eq $fasta_format){
	$bowtie_call = "$path_to_bowtie --quiet -f -v $mismatches --best --strata --all -p $aln_cores -S $bowtie_trans_index $input $trans_aligned --un $trans_unaligned";  ## always -f because of read condensation process
      }else{
	$bowtie_call = "$path_to_bowtie --quiet -v $mismatches --best --strata --all -p $aln_cores -S $bowtie_trans_index $input $trans_aligned --un $trans_unaligned";  ## always -f because of read condensation process
      }
      system($bowtie_call);
      #Sort sam file based on 1st column.
      `sort -T $output_path -k 1,1 $trans_aligned`;
      open(my $TRANS_ALIGNED_FILE, "<", $trans_aligned) or die;
      my %trans_aligned_reads;
      my $prev_id;
      my $read_id;
      my $first_time = 1;
     
      my $transcript_name;
      my $score;
      my $sequence;
      my $prev_sequence;
      my $quality;
      my $tag1;
      my $tag2;
      my $tag3;
      my $tag4;
           
      while (my $line = <$TRANS_ALIGNED_FILE>){
        
	if($line !~ /^@/){ #Avoid reading SAM header lines.
	  my @array = split('\t',$line);
	  $read_id = $array[0];
	  $transcript_name = $array[2];
	  my $score = $array[3];
	  $sequence = ();
	  $tag1 = $array[5];
	  $sequence = $array[9];
	  $quality = $array[10];
	  $tag2 = $array[11];
	  $tag3 = $array[12];
	  $tag4 = $array[13];

	  if($first_time and $transcript_name ne '*'){ $prev_id = $read_id; $first_time = 0; }

	  if($transcript_name ne '*'){

	    if( $prev_id ne $read_id ){ #New transcript.
	      #Select n transcripts with the highest alignment scores as obtained from alignment against the transcriptome.
	      my $tmp_hash = n_best_transcripts(\%trans_aligned_reads, $prev_id);
	      store_transcript($tmp_hash, $prev_id, $prev_sequence);
	      %trans_aligned_reads = ();
	    }
	    $prev_id = $read_id;
	    $prev_sequence = $sequence;
	    my $trans_key = $read_id.$SEPARATOR.$sequence.$SEPARATOR.$quality.$SEPARATOR.$tag1.$SEPARATOR.$tag2.$SEPARATOR.$tag3.$SEPARATOR.$tag4;
	    
	    $trans_aligned_reads{$score}{$transcript_name} = $trans_key;
	  }
	}
      }
      # Process the last lines of the file.
      my $tmp_hash = n_best_transcripts(\%trans_aligned_reads, $prev_id);
      store_transcript($tmp_hash, $prev_id, $prev_sequence);   
  }
}

#Select n best transcripts as obtained from the alignment to the transcriptome.
#All transcripts with the same score are considered as 1 out of n.
sub n_best_transcripts {

my %trans_aligned_reads = %{$_[0]};
my $read_id = $_[1];
my %tmp_hash;
my $count = 0;
my $first = 1;
my $prev_alignment_score;

my %read_attot; # Reads that were assigned to the same transcripts more than one time. 
                # That might be due to the very short length of the read. 
      
   foreach my $alignment_score (sort {$a <=> $b} keys %{trans_aligned_reads}){
    foreach my $transcript_name (sort keys %{$trans_aligned_reads{$alignment_score}}){  
      
        if(!exists $read_attot{$transcript_name}){
        
	  my $transcript_info = $trans_aligned_reads{$alignment_score}{$transcript_name};
	  #Select n transcripts with the highest score as obtained from the aligner.
	  $transcript_name =~ s/^\s+|\s+$//g;
	  if($first){ $prev_alignment_score = $alignment_score; $first = 0; $count++; }
	    if($alignment_score ne $prev_alignment_score) # Increase count only for not equal alignment scores.
	    {
	      $count++;
	    }
	  $tmp_hash{$alignment_score}{$transcript_name} = $transcript_info;
	  if($count eq $n_best_transcripts){ #Process n best transcript scores and select the one with the 
	    return(\%tmp_hash);
	  }
	  $prev_alignment_score = $alignment_score;
	
	}
	
	$read_attot{$transcript_name} = $transcript_name;
	
    }
   }
   return(\%tmp_hash);
}

#Store n best transcripts for selected reads into a proper global structure.
sub store_transcript {

  my %tmp_hash = %{$_[0]};
  my $read_id = $_[1];
  my $sequence = $_[2];

  #Check for existing transcripts and the assigned to them counts.
  foreach my $score ( sort {$a <=> $b} keys %{tmp_hash} ){
    foreach my $transcript_name (keys %{$tmp_hash{$score}}){
      my $key = $transcript_name{$transcript_name};
 
      my $info = $tmp_hash{$score}{$transcript_name};
      $info =~ s/^\s+|\s+$//g;
	#Check whether a specific transcript was already included in the previous steps.
	if(exists $transcripts{$key}){ 
	  foreach my $type (keys %{$transcripts{$key}}){
	    #Checking for assigned transcript counts.
	    $transcripts_transcriptome{$read_id}{$sequence}{$key}{$info}{$score} += $transcripts{$key}{$type};	   
	  }
	}else{ #If there is not existing assigned transcript, store it to the hash.
	  $transcripts_transcriptome{$read_id}{$sequence}{$key}{$info}{$score} = 0;
	}
    }
  }
  
  my $max_exp_trans = -1;
  foreach my $sequence (keys %{$transcripts_transcriptome{$read_id}}){
    foreach my $key (keys %{$transcripts_transcriptome{$read_id}{$sequence}}){
       foreach my $info (keys %{$transcripts_transcriptome{$read_id}{$sequence}{$key}}){
        foreach my $score (keys %{$transcripts_transcriptome{$read_id}{$sequence}{$key}{$info}}){
	  if($transcripts_transcriptome{$read_id}{$sequence}{$key}{$info}{$score} >= $max_exp_trans){
	    $max_exp_trans = $transcripts_transcriptome{$read_id}{$sequence}{$key}{$info}{$score};
	    $transcripts_transcriptome_maxExp{$read_id}{$max_exp_trans}++;	    
	  }
	    $transcripts_transcriptome_bestScore{$read_id}{$score}++;
        }
       }
    }
  }
  
}

#Store transcripts from transcriptome alignment to transcripts hash.
sub store_transcripts { 
  #Add transcripts from transcriptome alignment
  my %tmp;
  my $sum = 0;
  my $nr_keys = keys %transcripts_transcriptome;
  my $trans_count;
  
  foreach my $read_id (sort keys %transcripts_transcriptome){
  
    $trans_count = 0;
    my $mirna_indicator = 0;
    my %tmp_tmp;
    my $min_align_score = 1000000;
    my $existing_trans_count_counter = 0;
    my $trans_flag = 0;
    my $divide; #Divide the read among transcripts with equal maximum expression when one of the transcripts happens to be miRNA.
    my $bestScores_count;
    
    foreach my $max (sort {$b <=> $a} keys %{$transcripts_transcriptome_maxExp{$read_id}}){
      $divide = $transcripts_transcriptome_maxExp{$read_id}{$max};
      last;
    }
  
    foreach my $bestSc (sort {$a <=> $b} keys %{$transcripts_transcriptome_bestScore{$read_id}}){   
      $bestScores_count = $transcripts_transcriptome_bestScore{$read_id}{$bestSc};
      last;
    }
    
    foreach my $sequence (sort keys %{$transcripts_transcriptome{$read_id}}){
      foreach my $key (sort keys %{$transcripts_transcriptome{$read_id}{$sequence}}){
	foreach my $info (keys %{$transcripts_transcriptome{$read_id}{$sequence}{$key}}){	
	  foreach my $score (keys %{$transcripts_transcriptome{$read_id}{$sequence}{$key}{$info}}){	
	  $sum += $transcripts_transcriptome{$read_id}{$sequence}{$key}{$info}{$score};	  
	  $tmp{$read_id}{$sequence}{$key}{$info} = $transcripts_transcriptome{$read_id}{$sequence}{$key}{$info}{$score};
	  if($min_align_score >= $score){#If miRNA is present among the transcripts from the alignment, the final transcript
	  #that will be kept is the one with the best alignment score.
	    $min_align_score = $score;
	  }
	  #How many reads correspond to that transcript from the previous calculations.
	  my $existing_trans_count = $transcripts_transcriptome{$read_id}{$sequence}{$key}{$info}{$score};
	  $tmp_tmp{$existing_trans_count}{$score}{$read_id}{$key}{$info}{$sequence} = $existing_trans_count;
	  $trans_count++;
	  
	  if($key =~ /miRNA/){
	    $mirna_indicator = 1;
	  }
	  if($existing_trans_count > 1){
	    $trans_flag = 1;
	    $existing_trans_count_counter++;
	  }
	 }
	}
      }
    }
    
    my $counter = 0;
    my $alt_trans = $EMPTY;
    my $alt_flag = 0;
    my %a;
    my $glob_seq;
    my $glob_info;
    my $bestScores_count_tmp = $bestScores_count;
    my $divide_tmp = $divide;
    my $divide_flag = 0;
    my $bestScores_count_flag = 0;
    
    FOO: {	
    foreach my $trans_count (sort {$b <=> $a} keys %tmp_tmp){
      foreach my $score (sort {$a <=> $b} keys %{$tmp_tmp{$trans_count}}){
	foreach my $read_id (keys %{$tmp_tmp{$trans_count}{$score}}){

	      foreach my $key (sort keys %{$tmp_tmp{$trans_count}{$score}{$read_id}}){
	      
		 foreach my $info (keys %{$tmp_tmp{$trans_count}{$score}{$read_id}{$key}}) {
		 
		  foreach my $sequence (keys %{$tmp_tmp{$trans_count}{$score}{$read_id}{$key}{$info}}){
		
		      $glob_seq = $sequence;
		      $glob_info = $info;
		      
		      $bestScores_count_tmp--;
		      $divide_tmp--;
		      
		      if($mirna_indicator){# If miRNA transcripts are present in the transcripts then chose the best alignment score.
			  $a{$read_id}{$key}{$info}{$sequence} = $trans_count;
			  if($bestScores_count_tmp eq 0){
			    $bestScores_count_flag = 1;
			    last FOO;
			  }			  
		      }
		      elsif($trans_flag){# For reads aligned to the transcriptome, check whether there are
		      #transcripts from the previous analysis assigned already to those reads
			$counter++;
			$a{$read_id}{$key}{$info}{$sequence} = $trans_count;
			if($divide_tmp eq 0){
			  $divide_flag=1;
			  last FOO;
			}
		      }else{
			if($alt_trans eq $EMPTY){
			  $alt_trans = $key;
			}else{
			  $alt_trans = $alt_trans.$ALTERNATIVE_TRANS_SEPARATOR.$key;
			}		  
			$alt_flag = 1;
		      }
		      #If alt. transcripts for which previous transcript count exists is reached.
		      if($counter eq $existing_trans_count_counter and $counter ne 0){			  
			last FOO;
		      }
		    }
	    }
	  }
	}
      }
    }
    }
    if($alt_flag){    
      #Orer alternative transcripts according to the transcript name.
      my @altNames = split($ALTERNATIVE_TRANS_SEPARATOR,$alt_trans);
      my %alphabeticOrderTrans;
      foreach my $alt_name (@altNames){
	my @transNames = split($SEPARATOR,$alt_name);
	my $transName = $transNames[4];
	$alphabeticOrderTrans{$transName} = $alt_name;
      }
      my $ordered_alt_trans = $EMPTY;
      foreach my $ordered_key (sort keys %alphabeticOrderTrans){
	if($ordered_alt_trans eq $EMPTY){
	  $ordered_alt_trans = $alphabeticOrderTrans{$ordered_key};
	}else{
	  $ordered_alt_trans = $ordered_alt_trans.$ALTERNATIVE_TRANS_SEPARATOR.$alphabeticOrderTrans{$ordered_key};
	}	
      }
      $a{$read_id}{$ordered_alt_trans}{$glob_info}{$glob_seq} = $ordered_alt_trans;

    }

    foreach my $read_id (keys %a){    
	foreach my $key (sort keys %{$a{$read_id}}){
	  foreach my $info (keys %{$a{$read_id}{$key}}){
	  foreach my $sequence (sort keys %{$a{$read_id}{$key}{$info}}){
	    my @trans_key;
	    my @trans_info;
	    my $i=0;
	    my $j=0;
	    my $alt_trans_count;

	  if($collapsed){ #If collapse reads setting is activated.
	    
	    #Case of uniquely aligned read without previously existing matching annotation.
	    if( exists $no_indication_tag{$read_id} and $no_indication_tag{$read_id}{'counter'} eq 1 ){
		
	      if($divide_flag){
		$transcripts{$key}{$unique_type} += $read_tags{$read_id}/$divide;
		detect_isomir($key, create_info($key, $sequence) ,$read_tags{$read_id}/$divide);
	      }elsif($bestScores_count_flag){
		$transcripts{$key}{$unique_type} += $read_tags{$read_id}/$bestScores_count;
		detect_isomir($key, create_info($key, $sequence) ,$read_tags{$read_id}/$bestScores_count);
	      }else{
		$transcripts{$key}{$unique_type} += $read_tags{$read_id};
		detect_isomir($key, create_info($key, $sequence) ,$read_tags{$read_id});
	      }
    
	    }else{
	    
	      if($divide_flag){
		$transcripts{$key}{$non_unique_type} += $read_tags{$read_id}/$divide;
		detect_isomir($key, create_info($key, $sequence) ,$read_tags{$read_id}/$divide);
	      }elsif($bestScores_count_flag){
		$transcripts{$key}{$non_unique_type} += $read_tags{$read_id}/$bestScores_count;
		detect_isomir($key, create_info($key, $sequence) ,$read_tags{$read_id}/$bestScores_count);
	      }else{
		$transcripts{$key}{$non_unique_type} += $read_tags{$read_id};
		detect_isomir($key, create_info($key, $sequence) ,$read_tags{$read_id});
		
	     }		
	   }
	  }
	 }
	}
      }
    }
    %tmp = ();
    $sum = 0;
  } 
}

#Helper functions for creation info of read alignment.
sub create_info {

  my $key = shift;
  my $sequence = shift;

  my @arr = split($SEPARATOR, $key);
  my $chr = $arr[0];
  my $biotype = $arr[1];
  my $id = $arr[2];
  my $strand = $arr[3];
  my $tr_name = $arr[4];
  my $start_pos = $arr[5];
  my $stop_pos = $arr[6];
  my $info = $chr.$SEPARATOR.$strand.$SEPARATOR.$start_pos.$SEPARATOR.$stop_pos.$SEPARATOR.$sequence.$SEPARATOR.$sequence;

  return($info);

}

#Helper function for parsing info.
sub split_info {

  my $info = shift;
  
  my @info_elements = split($SEPARATOR, $info);
  my $read_id = $info_elements[0];
  my $chromosome = $info_elements[1];
  my $strand = $info_elements[2];
  my $start_pos = $info_elements[3];
  my $stop_pos = $info_elements[4];
  my $read = $info_elements[5];
  my $quality = $info_elements[6];
  my $tag1 = $info_elements[7];
  my $tag2 = $info_elements[8];
  my $tag3 = $info_elements[9];
  my $tag4 = $info_elements[10];
  my $multimap_loci = $info_elements[11];
 
  return ($read_id, $chromosome, $strand, $start_pos, $stop_pos, $read, $quality, $tag1, $tag2, $tag3, $tag4, $multimap_loci);
  
}

#Helper function for generating info.
sub generate_info {

my $line = shift;
my $read_id = shift;

my @sam_elements = split('\t', $line);
	my $strand;
	if($strand_specific){
	  if($sam_elements[1] eq '16'){
	    $strand = '-';
	  }elsif($sam_elements[1] eq '0'){
	    $strand = '+';
	  }
	}else{
	  $strand = $NA;
	}
	my $chromosome = $sam_elements[2];

	if($chromosome =~ /[Cc]hr/){
	  $chromosome = substr($chromosome,3);
	}

	my $start_pos = $sam_elements[3];
	my $read_length = length($sam_elements[9]);
	my $stop_pos = $start_pos + $read_length -1;
	my $read = $sam_elements[9];
 	my $quality = $sam_elements[10];
 	
 	my $tag1 = $sam_elements[5];
 	my $tag2 = $sam_elements[11];
 	my $tag3 = $sam_elements[12];
 	my $tag4 = $sam_elements[13];
	my $info = $read_id.$SEPARATOR.$chromosome.$SEPARATOR.$strand.$SEPARATOR.$start_pos.$SEPARATOR.$stop_pos.$SEPARATOR.$read.$SEPARATOR.$quality.$SEPARATOR.$tag1.$SEPARATOR.$tag2.$SEPARATOR.$tag3.$SEPARATOR.$tag4;
	return $info;

}

#Check the input file format, fasta or fastq.
sub file_format {
  
  my $file_format;
  my $input_file = shift;
  
  my $first_line = `head -1 $input_file`;
  
  if($first_line =~ /^>/){
    $file_format = $fasta_format;
  }else{
    $file_format = $fastq_format;
  }
   return $file_format;
   
}

#Quantify reads.
sub quantify {

open(my $TMP_SAM, "<", $tmp_sam);

my $prev_ead_id = '';
my $continue = 1;
my $reads_non_accordance = 0;
my $tot_reads = 0;
my $no_indication = 1;
my $only_annotation = 1;
my $only_unique = 1;
my %hash;
my $prev_read_id;
my $counter = 0;
my %tmp_hash = ();

while(my $line = <$TMP_SAM>){

  chomp $line;
  
  my ($read_id, $chromosome, $strand, $start_pos, $stop_pos, $read, $quality, $tag1, $tag2, $tag3, $tag4, $multimap) = split_info($line);
  if($counter < $multimap){
    my $info = $chromosome.$SEPARATOR.$strand.$SEPARATOR.$start_pos.$SEPARATOR.$stop_pos.$SEPARATOR.$read.$SEPARATOR.$quality.$SEPARATOR.$tag1.$SEPARATOR.$tag2.$SEPARATOR.$tag3.$SEPARATOR.$tag4;
    my $read_length = $stop_pos - $start_pos + 1;
    $tmp_hash{$chromosome}{$strand}{$start_pos}{$stop_pos} = $info;
    $counter++;  
  }
  
  #Tmp hash for a multimapped read.
  my %multimaps;
  
  if($counter eq $multimap){ #Reached all the multimapping regions for one read.
  
    my $indication = 0;
    my %score = ();
    
    my $uniques_flag;
    my $annotation_flag;
    
    foreach my $chromosome (keys %{tmp_hash}){
      foreach my $strand (keys %{$tmp_hash{$chromosome}}){
	foreach my $start_pos (keys %{$tmp_hash{$chromosome}{$strand}}){
	  foreach my $stop_pos (keys %{$tmp_hash{$chromosome}{$strand}{$start_pos}}){
	  
	    if(!exists $score{$tmp_hash{$chromosome}{$strand}{$start_pos}{$stop_pos}}){
	      $score{$tmp_hash{$chromosome}{$strand}{$start_pos}{$stop_pos}} = 0;
	    }
	   
	    my $read_length = $stop_pos - $start_pos + 1;
	 	   
	    $uniques_flag = 0;

	    for (my $i = $start_pos - $multimap_range; $i <= $start_pos + $read_length + $multimap_range - 1; $i++){

	      my $key = $chromosome . $SEPARATOR . $strand . $SEPARATOR . $i;
	      if(exists $densities{$key}){ #Assign score to multimap read based on UAR densities.
	        $indication = 1;
	        $uniques_flag = 1;
		if($i >= $start_pos and $i <= $stop_pos){
		  $score{$tmp_hash{$chromosome}{$strand}{$start_pos}{$stop_pos}} += $densities{$key};
		}elsif($i >= $start_pos - $multimap_range and $i < $start_pos){ #Downstram		  
		  $score{$tmp_hash{$chromosome}{$strand}{$start_pos}{$stop_pos}} += $densities{$key}*$range_downstream[($start_pos-$i-1)];
		}else{ #Upstream
		  my $tt = $i-$stop_pos;
		  $score{$tmp_hash{$chromosome}{$strand}{$start_pos}{$stop_pos}} += $densities{$key}*$range_upstream[($i-$stop_pos-1)];
		}
	      }
	    }

	    #Fetch annotation for a multimap.
	    my $results = $annotation->fetch($start_pos, $stop_pos);
	    my %annotation_tmp;
	    $annotation_flag = 0;
	    my $strand_reg = "\\".$strand;
	    for ( my $i = 0; $i <= $#{ $results }; $i++ )
	    {
	      if($results->[$i] =~ /^$chromosome$SEPARATOR$strand_reg/){ 
		$indication = 1;
		$annotation_flag = 1;
		$annotation_tmp{$start_pos}{$stop_pos}{$read_length}{$results->[$i]} = $results->[$i];
	      }
	    }
	    my $best_fitted_transcript;
	    my $min_ratio;
	    if($annotation_flag){ #Select the best fitted transcript for a specific read. 
	      $best_fitted_transcript = best_fitted_transcript(\%annotation_tmp);
	    }else{
	      $best_fitted_transcript = $no_annotation_flag;
	    }
	    $multimaps{$tmp_hash{$chromosome}{$strand}{$start_pos}{$stop_pos}}{'score'} =  $score{$tmp_hash{$chromosome}{$strand}{$start_pos}{$stop_pos}};
	    $multimaps{$tmp_hash{$chromosome}{$strand}{$start_pos}{$stop_pos}}{'annotation'} = $best_fitted_transcript;	    	    
	  }
	  %score = ();
	}
	%score = ();
      }
      %score = ();
    }
    if($indication eq 0){ #No unique reads or annotation was found for those multimaps.
     foreach my $chromosome (keys %{tmp_hash}){
      foreach my $strand (keys %{$tmp_hash{$chromosome}}){
	foreach my $start_pos (keys %{$tmp_hash{$chromosome}{$strand}}){
	  foreach my $stop_pos (keys %{$tmp_hash{$chromosome}{$strand}{$start_pos}}){
		my $info = $tmp_hash{$chromosome}{$strand}{$start_pos}{$stop_pos};
		print $NO_INDICATION_FILE "$read_id$SEPARATOR$info$SEPARATOR$multimap\n";
	  }
	}
      }
     }
    }
    %tmp_hash = ();
    %score = ();
    $counter = 0;
    $tot_reads++;
    assign(\%multimaps, $read_id);
    %multimaps = ();
  }  
}

}

#Main function for transcript count assignment.
sub assign {

   my %multimaps = %{$_[0]};
   my $read_id = $_[1];
   my $score_sum = 0;
   my $no_annotation_sum = 0;
   my %tmp;
   my $annotation_unique = 0;
   my $unique = 0;
   my $annotation = 0;
   
   my %sam;
     
   foreach my $key (keys %{multimaps}){
    if($multimaps{$key}{'score'} ne 0 and $multimaps{$key}{'annotation'} ne $no_annotation_flag){ #Region/regions with both annotation and uniques.
      $annotation_unique++;
    } 
     if($multimaps{$key}{'score'} ne 0 and $multimaps{$key}{'annotation'} eq $no_annotation_flag){ #Region/regions with only uniques.
      $unique++;
     }
    if($multimaps{$key}{'score'} eq 0 and $multimaps{$key}{'annotation'} ne $no_annotation_flag){ #Region/regions with only annotation.
      $annotation++;
    }
   }

   my $max_score = 0;
   my $max_score_key;
   if($unique > 0 and $annotation_unique eq 0 and $annotation eq 0){ #Multimappeed
	foreach my $key (keys %{multimaps}){
	  foreach my $type (keys %{$multimaps{$key}}){
 	    if($type eq 'score'){	    
 	    	if($multimaps{$key}{'score'} >= $max_score ){
		  $max_score_key = $key;
		  $max_score = $multimaps{$key}{'score'};
 	    	}   
 	    }
	  }
	}
   }
    my $sum_score = 0;
    if($annotation_unique eq 1){ #Unique annotation and UARs.
   
      foreach my $key (keys %{multimaps}){
     
        # Select only the combination with annotation and UARs.
	if( ( $multimaps{$key}{'annotation'} ne $no_annotation_flag ) and ($multimaps{$key}{'score'} ne 0) ){
	    if($collapsed){
	      $transcripts{$multimaps{$key}{'annotation'}}{$non_unique_type} += $read_tags{$read_id};
	      detect_isomir($multimaps{$key}{'annotation'}, $key, $read_tags{$read_id});
	    }else{
	      $transcripts{$multimaps{$key}{'annotation'}}{$non_unique_type}++;
	      detect_isomir($multimaps{$key}{'annotation'}, $key, 1);
	    }
	}
      }
    }elsif($annotation_unique >= 1){ #Case where both annotation and unique reads are present for multiple multimapping regions.
       my $sum_score_count = 0;
       foreach my $key (keys %{multimaps}){
     
	if( ( $multimaps{$key}{'annotation'} ne $no_annotation_flag ) and ($multimaps{$key}{'score'} ne 0) ){
	  $sum_score += $multimaps{$key}{'score'};
	  $sum_score_count++;
	}
	
       }
       
       foreach my $key (keys %{multimaps}){ 
        if( ( $multimaps{$key}{'annotation'} ne $no_annotation_flag ) and ($multimaps{$key}{'score'} ne 0) ){
	    if($collapsed){
	      $transcripts{$multimaps{$key}{'annotation'}}{$non_unique_type} += $read_tags{$read_id}*($multimaps{$key}{'score'}/$sum_score); #Divide th
	      detect_isomir($multimaps{$key}{'annotation'}, $key, $read_tags{$read_id}*($multimaps{$key}{'score'}/$sum_score));
	   }else{
	      $transcripts{$multimaps{$key}{'annotation'}}{$non_unique_type} += ($multimaps{$key}{'score'}/$sum_score); #Divide the
	      detect_isomir($multimaps{$key}{'annotation'}, $key, $multimaps{$key}{'score'}/$sum_score);
	    }	    
	}
       }
    }elsif($unique and $annotation){ #Prefer annotation instead of unique in case they do not match.
       my %annotation_tmp;
       my $mirna_flag = 0;
       my %tmp_hash;
       foreach my $key (keys %{multimaps}){
       
        if($multimaps{$key}{'annotation'} ne $no_annotation_flag){
	  my @tmp_arr1 = split($SEPARATOR, $key);
	  my $start_pos = $tmp_arr1[2];
	  my $stop_pos = $tmp_arr1[3];
	  my $read_length = $stop_pos - $start_pos + 1;
	  $annotation_tmp{$start_pos}{$stop_pos}{$read_length}{$multimaps{$key}{'annotation'}} = $multimaps{$key}{'annotation'}; 
	  my @tmp_arr2 = split($SEPARATOR, $multimaps{$key}{'annotation'});
	  $tmp_hash{$tmp_arr2[4]} = $key;
	}
       }
       
       my $best_fitted_transcript = best_fitted_transcript(\%annotation_tmp);
       my @bft = split($ALTERNATIVE_TRANS_SEPARATOR, $best_fitted_transcript);
       my @first_annotation = split($SEPARATOR, $bft[0]);
       
       my $annotation_mirna;
       my $key_mirna; 
       foreach my $key (keys %{multimaps}){
        if($multimaps{$key}{'annotation'} ne $no_annotation_flag){
	    if($multimaps{$key}{'annotation'} =~ /miRNA/ and $multimaps{$key}{'annotation'} eq $best_fitted_transcript){
	      $mirna_flag = 1;
	      $annotation_mirna = $multimaps{$key}{'annotation'};
	      $key_mirna = $key;
	      last;
	    }
	}
       }
	if($collapsed){
	  $transcripts{$best_fitted_transcript}{$non_unique_type} += $read_tags{$read_id};
	  if($mirna_flag){
	    detect_isomir($annotation_mirna, $key_mirna, $read_tags{$read_id});
	  }
	  
	}else{
	  $transcripts{$best_fitted_transcript}{$non_unique_type}++;
	  if($mirna_flag){
	    detect_isomir($annotation_mirna, $key_mirna, 1);
	  }
	}
    }
    elsif(!$unique and $annotation){ #Only annotation available.
    
       my $mirna_flag = 0;
       my %annotation_tmp;
       
       my %hash;
       
       my %tmp_hash;
       
       foreach my $key (keys %{multimaps}){

        my @tmp_arr1 = split($SEPARATOR, $key);
        my $start_pos = $tmp_arr1[2];
        my $stop_pos = $tmp_arr1[3];
        my $read_length = $stop_pos - $start_pos + 1;

	$annotation_tmp{$start_pos}{$stop_pos}{$read_length}{$multimaps{$key}{'annotation'}} = $multimaps{$key}{'annotation'};
	$hash{$multimaps{$key}{'annotation'}} = $key;
	
	my @tmp_arr2 = split($SEPARATOR, $multimaps{$key}{'annotation'});
	if($multimaps{$key}{'annotation'} ne $no_annotation_flag){
	  $tmp_hash{$tmp_arr2[4]} = $key;
	}
	
       }
             
       my $best_fitted_transcript = best_fitted_transcript(\%annotation_tmp);
       my @bft = split($ALTERNATIVE_TRANS_SEPARATOR, $best_fitted_transcript);
       my @first_annotation = split($SEPARATOR, $bft[0]);
       
       my $annotation_mirna;
       my $key_mirna; 
       foreach my $key (keys %{multimaps}){
        if($multimaps{$key}{'annotation'} ne $no_annotation_flag){
	    if($multimaps{$key}{'annotation'} =~ /miRNA/ and $multimaps{$key}{'annotation'} eq $best_fitted_transcript){
	      $mirna_flag = 1;
	      $annotation_mirna = $multimaps{$key}{'annotation'};
	      $key_mirna = $key;
	      last;
	    }
	}
       }
	if($collapsed){
	  if(exists $transcripts{$best_fitted_transcript}){
	    $transcripts{$best_fitted_transcript}{$non_unique_type} += $read_tags{$read_id};
	  }else{
	    $transcripts{$best_fitted_transcript}{$non_unique_type} = $read_tags{$read_id};
	  }
	 if($mirna_flag){
	    detect_isomir($annotation_mirna, $key_mirna, $read_tags{$read_id});
	  }
	}else{	
	  if(exists $transcripts{$best_fitted_transcript}){
	    $transcripts{$best_fitted_transcript}{$non_unique_type} = 1;
	  }else{
	    $transcripts{$best_fitted_transcript}{$non_unique_type}++;
	  }
	 if($mirna_flag){
	    detect_isomir($annotation_mirna, $key_mirna, 1);
	  }
	}
    }
}

#Process mapped reads and create temp file with aligned 
## reads and their corresponding counts.
sub reads_process {

my $SAM_FILE = shift;

my %read_counts; 
my $strand;
my $chromosome;
my $start_pos;
my $stop_pos;
my %reads_ids;

my $lines_counter = 0;
open(SAM_FILE, "<", $SAM_FILE);
open(my $TMP_SAM, ">", $tmp_sam);

my $first_line = 1;
my $prev_read_id;
my $read_id;
my $count = 0;
my %tmp;
my $prev_line;

  while (my $line = <SAM_FILE>) {
  
      $lines_counter++;
      chomp $line;
      if($line !~ /^@/) {
      my @array = split('\t',$line);
      if($array[1] ne 4 && $array[2] ne '*'){ #Count only mapped reads.
      
	$read_id = $array[0];

	$read_id =~ s/^\s+|\s+$//g; 
	if($first_line){$prev_read_id = $read_id; $prev_line = $line; $first_line = 0;}
	  if($prev_read_id eq $read_id){
	    $tmp{generate_info($line, $read_id)} = generate_info($line, $read_id);
	  }else{
	      my $mltp = keys %tmp;

	      if($mltp eq 1){
		$uniquely_aligned_count++;
		densities_and_transcripts(\%tmp);
	      }else{
	        #Write multimaps into temp file 
	        #in Manate format.
		foreach my $info (keys %tmp){
		  print $TMP_SAM "$info$SEPARATOR$mltp\n";
		}
	      }
	       %tmp = ();
	       $tmp{generate_info($line, $read_id)} = generate_info($line, $read_id);
	       
	       
	       if($collapsed){
		$mapped_reads += $read_tags{$read_id};
	       }else{
		$mapped_reads++;
	       }
	  }
	  $prev_read_id = $read_id;
	  $prev_line = $line;
	}else{
	  $global_unaligned_tag = $array[11];
	}
      }
  }
  my $mltp = keys %tmp;
  if($mltp eq 1){ #The last line of the input file.
    densities_and_transcripts(\%tmp);
    $uniquely_aligned_count++;
  }else{
    foreach my $info (keys %tmp){
      print $TMP_SAM "$info$SEPARATOR$mltp\n";
    }
  }

  if($collapsed){
    $mapped_reads += $read_tags{$read_id};
    }else{
    $mapped_reads++;
  }
  
  close(SAM_FILE);
  close($TMP_SAM);

}

#Select the best fitted transcript.
sub best_fitted_transcript {

  my %tmp = %{$_[0]};

  my $best_fitted_transcript = "";
  my $tmp_best_fitted_transcript = "";
  my $existing_best_fitted_transcript;
  my $ratio;
  my $min_ratio = 10**9; #Select some large number.
  my $mirna_flag = 0;
  my $test_flag = 0;
  #Check whether any of the alignments is associated with miRNA annotation.
   foreach my $start_pos (sort {$a <=> $b} keys %{tmp}){
    foreach my $stop_pos (sort {$a <=> $b} keys %{$tmp{$start_pos}}){
      foreach my $read_length (sort {$a <=> $b} keys %{$tmp{$start_pos}{$stop_pos}}){
	foreach my $annotation (sort keys %{$tmp{$start_pos}{$stop_pos}{$read_length}}){
	  if($annotation ne $no_annotation_flag){
	    if($annotation =~ /miRNA/){
	      $mirna_flag = 1;
	    }
	  }
	}
      }
    }
   }

  foreach my $start_pos (sort {$a <=> $b} keys %{tmp}){
    foreach my $stop_pos (sort {$a <=> $b} keys %{$tmp{$start_pos}}){
      foreach my $read_length (sort {$a <=> $b} keys %{$tmp{$start_pos}{$stop_pos}}){
	foreach my $annotation (sort keys %{$tmp{$start_pos}{$stop_pos}{$read_length}}){
	  if($annotation ne $no_annotation_flag){
	    if($mirna_flag){
	      my @arrays;
	      if($annotation =~ /$ALTERNATIVE_TRANS_SEPARATOR/){
		@arrays = split($ALTERNATIVE_TRANS_SEPARATOR,$annotation);
	      }else{
		$arrays[0] = $annotation;
	      }
	      foreach my $annotation_sep (@arrays){
		my @arr = split($SEPARATOR, $annotation_sep);
		my $start_tr = $arr[5];
		my $stop_tr = $arr[6];
		my $tr_len = $stop_tr - $start_tr + 1;
		my $start = ($start_tr, $start_pos)[$start_tr < $start_pos]; #Max
		my $end = ($stop_tr, $stop_pos)[$stop_tr > $stop_pos]; #Min
		my $cov = $end - $start + 1;
		$ratio = (($tr_len+$read_length)/2)/$cov;
		$ratio = abs(1-$ratio);
		if($ratio <= $min_ratio){
		  $best_fitted_transcript = $annotation_sep;
		  $min_ratio = $ratio;
		}
	      }
	     
	    }else{ #If no miRNA annotation was used 
	      if($best_fitted_transcript eq ""){
		$best_fitted_transcript = $annotation;
	      }else{
		$best_fitted_transcript = $best_fitted_transcript.$ALTERNATIVE_TRANS_SEPARATOR.$annotation;
	      }
	    }
	  }
	}
      }
    }
  }
  return $best_fitted_transcript;

}

#Save isomir to a proper structure.
sub detect_isomir {

  my $annotation = shift;
  my $key = shift;
  my $times = shift;
  my @arr = split($SEPARATOR, $annotation);
  my $trans_name = $arr[4];
  @arr = split($SEPARATOR, $transcript_name{$trans_name});
  my $biotype = $arr[3];
  if($biotype eq "miRNA"){
    @arr = split($SEPARATOR, $key);
    my $sequence = $arr[4];
    $isomirs{$trans_name}{$sequence} += $times;
  }
}


#Create densities of uniquely aligned reads and assign uniquely aligned reads to available annotation.
sub densities_and_transcripts {

  my %tmp = %{$_[0]};

  my $read_id;
  my $chromosome;
  my $strand;
  my $start_pos;
  my $stop_pos;
  my $read_length;
  
  foreach my $info (keys %{tmp}){ #Always only one element because there is only one unique read.

    my @element = split($SEPARATOR, $info);
    
    $read_id = $element[0];
    $chromosome = $element[1];
    $strand = $element[2];
    $start_pos = $element[3];
    $stop_pos = $element[4];

    my $strand_reg = "\\".$strand;
    
    $read_length = $stop_pos - $start_pos + 1;
    
    my $results = $annotation->fetch($start_pos, $stop_pos);
   
    my %annotation_tmp;
   
    my $annotation_flag = 0; 
    for ( my $i = 0; $i <= $#{ $results }; $i++ )
    {
      if($results->[$i] =~ /^$chromosome$SEPARATOR$strand_reg/){ 
	$annotation_flag = 1;
	$annotation_tmp{$start_pos}{$stop_pos}{$read_length}{$results->[$i]} = $results->[$i];
      }
    }
    
    $info = $info.$SEPARATOR.'UAR';
    if($annotation_flag){

    #Store annotation for UARs
    my $best_fitted_transcript = best_fitted_transcript(\%annotation_tmp);
    
    if($best_fitted_transcript =~ /miRNA/){
      
      my @bft = split($SEPARATOR, $best_fitted_transcript);
      my @arr = split($SEPARATOR, $info);
      my $read_id = $arr[0];
      my $chromosome = $arr[1];
      my $strand = $arr[2];
      my $start = $arr[3];
      my $stop = $arr[4];
      my $sequence = $arr[5];
      my $quality = $arr[6];

      my $mirna_annotation = $chromosome.$SEPARATOR."miRNA".$SEPARATOR."".$SEPARATOR.$strand.$SEPARATOR.$bft[4];
      my $mirna_key = $chromosome.$SEPARATOR.$strand.$SEPARATOR.$start.$SEPARATOR.$stop.$SEPARATOR.$sequence.$SEPARATOR.$quality;

      if($collapsed){
	      detect_isomir($mirna_annotation, $mirna_key, $read_tags{$read_id});
      }else{
	      detect_isomir($mirna_annotation, $mirna_key, 1);
      }

    }

      #Collapsed reads
      if(exists $transcripts{$best_fitted_transcript}{$unique_type}){
	if($collapsed){
	  $transcripts{$best_fitted_transcript}{$unique_type} += $read_tags{$read_id};	  
	}else{
	  $transcripts{$best_fitted_transcript}{$unique_type}++;
	}
      }else{
	if($collapsed){
	  $transcripts{$best_fitted_transcript}{$unique_type} = $read_tags{$read_id};
	}else{
	  $transcripts{$best_fitted_transcript}{$unique_type} = 1;
	}
      }
    }else{ #Store uniquely aligned reads without existing annotation in a file.
    
        my $key = $info.$SEPARATOR."1";
 	my @arr = split($SEPARATOR, $info);
 	my $sequence = $arr[5];
 	my $quality = $arr[6];
 	print $NO_INDICATION_FILE "$key\n";
 	
    }
  }
  
  for (my $i=0; $i < $read_length; $i++){
  
    my $nucleotide = $start_pos + $i;
    $nucleotide =~ s/^\s+|\s+$//g; 
    my $key =  "$chromosome" . $SEPARATOR . $strand . $SEPARATOR . "$nucleotide";

    if(exists $densities{$key}){
    
      if($collapsed){
	$densities{$key} += $read_tags{$read_id};
      }else{
	$densities{$key} += 1;
      }
    }else{
      if($collapsed){
	$densities{$key} = $read_tags{$read_id};
      }else{
	$densities{$key} = 1;
      }
    }
  }
}

#Display help options.
sub get_help {
print "\nManatee version $version

USAGE with configuration file
	
manatee -config <file> -i <file> -o <dir>
	
OR 

USAGE with input parameters
	
manatee [options] -i <file> -o <dir> -index <ebwt> -genome <file> -annotation <file>
	
-config <file>       : Path to configuration file.

-i <file>            : Path to pre-processed FASTQ or FASTA file.

-o <dir>             : Path to directory where the output will be stored.

-index <ebwt>        : Path and basename of the genome index to be searched. 
		       The basename is the name of any of the index files 
                       up to but not including the final 
                       .1.ebwt/.rev.1.ebwt/etc. 
	
-genome <file>       : Path to genome fa or fasta file. 
	
-annotation <file>   : Path to annotation file in GFF3/GTF format. File should contain 
		       non-coding annotation. 
	
OPTIONS
   
-t_index <ebwt>      : Path and basename of the transcriptome index to be searched. 
                       The basename is the name of any of the index files 
                       up to but not including the final .1.ebwt/.rev.1.ebwt/etc. 
                       If left blank, Manatee will generate transcriptome 
                       index based on the non coding annotation present in provided
                       annotation file and will store that index within the trans-index 
                       directory.
	
-cores <int>         : Number of alignment cores (default: -cores 1)

-m <int>             : Max of multimapping loci, -m in bowtie execution. The mapping algorithm 
                       will be applied only for reads with multi-mapped loci less or equal than m. 
                       Reads with multimapped loci that exceed the -m will be aligned against 
                       transcriptome (default: -m 50).
                       
-mismatches <int>    : Maximun number of mismatches in genomic alignments (default: mismatches=1).
	
-s <yes/no>          : Strand specific mode of the algorithm (default -s yes).
	
-cd <int>            : Minimum number of unannotated read abundances per cluster (default: -cd 5).
	
-cdi <int>           : Clusters of unannotated reads will be merged if the distance between them 
                       is equal or less than cdi (default: -cdi 50).
                       
-collapse <yes/no>   : Collapse reads with the same genomic sequence. This setting 
	               reduces significantly the execution time. Possible values 
	               yes/no (default: -collapse yes).                      
	
";
}

#Print user input parameters.
sub print_user_input {
  print "\n";
  print "Manatee $version\n\n";
  print "---------- Input ----------\n\n";
  print "Bowtie index: $path_to_bowtie_index\n\n";
  print "Annotation: $annotation_file\n\n";
  print "Reference genome file: $reference_genome\n\n";
  if($bowtie_trans_index eq $NOT_SPECIFIED){
    if(check_index($bowtie_trans_index) eq $NOT_SPECIFIED){
      print "Transcriptome index: not specified. Index will be generated based on provided annotation.\n\n";
    }else{
      print "Transcriptome index: not specified. Index related to provided annotation file already exists in trans-index directory.\n\n";
    }
  }else{
      print "Transcriptome index: $bowtie_trans_index\n\n";
  }
  print "Alignment cores: $aln_cores\n\n";
  print "Bowtie -m: $m\n\n";
  print "Alignment mismatches: $mismatches\n\n";
  print "Input data file: $input_file\n\n";
  if($strand_specific){
    print "Strand specificity: yes\n\n";
  }else{
    print "Strand specificity: no\n\n";
  }
  print "--------------------------------------\n\n";
  print "Processing data ...\n\n";
}

#Check if proper bowtie index exists.
sub check_index {

      my($path) = @_;

      if($path eq $NOT_SPECIFIED){ #If transcriptome index is not specified, additional check in 
                                   #transcripts dir is performed.
	my @full_path = split('/',$annotation_file);
	my $check = $RealBin.$slash.$bowtie_trans_index_dir.$slash.$full_path[$#full_path];
	if( -s $check.'.1.ebwt' && 
	  -s $check.'.2.ebwt' &&
	  -s $check.'.3.ebwt' &&
	  -s $check.'.4.ebwt' &&
	  -s $check.'.rev.1.ebwt' &&
	  -s $check.'.rev.2.ebwt'){ 
	    my $bowtie_trans_index = $RealBin.$slash.$bowtie_trans_index_dir.$slash.$full_path[$#full_path];
	    return $bowtie_trans_index; #Transcriptome index related to provided anotation found in transcripts directory.
	}else{
	    return $NOT_SPECIFIED; #Transcriptome index undefined and not found in transciptome directory. Index will be generated based
	                           #on the provided annotation file.
	}
      }else{
	if( -s $path.'.1.ebwt' && 
	  -s $path.'.2.ebwt' &&
	  -s $path.'.3.ebwt' &&
	  -s $path.'.4.ebwt' &&
	  -s $path.'.rev.1.ebwt' &&
	  -s $path.'.rev.2.ebwt'){ #If defined bowtie genome index exists.
	    return $path;
	}else{
	    print "\nThe provided transcriptome index does not exist or is incorrect.
If the parameter t_index is left blank, Manatee will create the transcriptome index based on the provided annotation. \n\n";
	    exit;
	}
      }
}

#Store annotation file into hash structures.
sub process_annotation {

  my $ANNOTATION_FILE = shift;
  
  if(open ANNOTATION_FILE, "<", $ANNOTATION_FILE) { #Open annotation file provided as input or configuration parameter
      while (my $line = <ANNOTATION_FILE>){
      #Process each line of the annotation file.
      chomp $line;

      if($line =~ /^##FASTA/){ return;} #FASTA section if present resides at the end of the GFF file
      if($line !~ /^#/){ #Don't read comments.
      
       	my @element = split('\t',$line);
 	my $chromosome = $element[0];
	if($chromosome =~ /[Cc]hr/){
	  $chromosome = substr($chromosome,3);
	}	   
		
 	my $start = $element[3];
        $start =~ s/^\s+|\s+$//g;
  	my $end = $element[4];
 	$end =~ s/^\s+|\s+$//g;
        my $strand;
        if($strand_specific){
	  $strand = $element[6];
        }else{
	  $strand = $NA;
        }
        $strand =~ s/^\s+|\s+$//g;
        
        my @attributes = split(';', $element[8]);
        my $gene_name;
        my $gene_biotype; 
        my $gene_id;
        
        foreach my $attribute (@attributes){
          my @subattributes;
	  if($attribute =~ /gene_name/){
	    if($attribute =~ /=/){
	      @subattributes = split('=', $attribute);
	    }else{
	      @subattributes = split(' ', $attribute);
	    }
	    if($subattributes[-1] =~ /"/){
	      $gene_name = substr($subattributes[-1],1,-1);
	    }else{
	      $gene_name = $subattributes[-1];
	    }
	  }
	  if($attribute =~ /gene_biotype/){	    
	    if($attribute =~ /=/){
	      @subattributes = split('=', $attribute);
	    }else{
	      @subattributes = split(' ', $attribute);
	    }
	    if($subattributes[-1] =~ /"/){
	      $gene_biotype = substr($subattributes[-1],1,-1);
	    }else{
	      $gene_biotype = $subattributes[-1];
	    } 
	  }
	  if($attribute =~ /gene_id/){
	    if($attribute =~ /=/){
	      @subattributes = split('=', $attribute);
	    }else{
	      @subattributes = split(' ', $attribute);
	    }
	    if($subattributes[-1] =~ /"/){
	      $gene_id = substr($subattributes[-1],1,-1);
	    }else{
	      $gene_id = $subattributes[-1];
	    } 
	  }
        }

	my $transcript_info = $gene_id.$SEPARATOR.$gene_biotype.$SEPARATOR.$gene_name;
	my $full_info = $chromosome.$SEPARATOR.$strand.$SEPARATOR.$transcript_info.$SEPARATOR.$start.$SEPARATOR.$end;
	$annotation->insert($full_info, $start,$end);

	$gtf{$chromosome}{$strand}{$start}{$end} = $transcript_info;

	$transcript_name{$gene_name} = $full_info;
	
	$gtf_simplified{$gene_id} = $gene_biotype;
      }
    }
  }else{
    print "Could not open annotation file: $ANNOTATION_FILE\n";
    exit 10;
  }
}

#Split the input path to file name and path.
sub get_input_filename_base_path { 

  my $input = shift;
  $input =~ s/^\s+|\s+$//g; # Removing leading and trailing white spaces.
  my @path_parts = split('/',$input);
  my $file_id;
  my $bam_file;
  my $sam_file;
  if($input =~ /.fa$/ || $input =~ /.fq$/){
    $input_base_name = substr($path_parts[$#path_parts], 0, -3);
    $input_path = substr($input, 0, -(3+length($input_base_name)));
  }elsif($input =~ /.fasta$/ || $input =~ /.fastq$/){
    $input_base_name = substr($path_parts[$#path_parts], 0, -6);
    $input_path = substr($input, 0, -(6+length($input_base_name)));
  }else{
    print "FATAL: Could not determine the format of the reads file $input .. Accepted extensions: .fa, .fasta, .fq, or .fastq\n";
    remove_output();
    exit;
  }
}

#Process input fasta/fa file, merge identical reads, store all the reads to specific hashes.
sub process_input {

  my $input_file = shift;
  my $output_file = shift;
  open(OUTPUT, ">", $output_file) or die "Couldn't open output file for reading: $output_file\n\n";
  open(INPUT, "<", $input_file) or die "Couldn't open input file: $input_file\n\n";
  if($input_file_format eq $fastq_format){ # Fastq file
    my $line_nr = 1;
    my $counter = 1;
    my $sequence;
    my $quality;
    while(<INPUT>){
      chomp $_;
      $_ =~ s/^\s+|\s+$//g;
      if($line_nr % 4 eq 2){
        $sequence = $_
      }elsif($line_nr % 4 eq 0){
	$quality = $_;
	$quality = 'A' x length($sequence);
	if(exists $collapsed_reads{$sequence}{$quality}){
	  $collapsed_reads{$sequence}{$quality}++;
	}else{
	  $collapsed_reads{$sequence}{$quality} = 1;
	}
      }
      $line_nr++;
    }
    foreach my $sequence (keys %{collapsed_reads}){
      foreach my $quality (keys %{$collapsed_reads{$sequence}}){
	  my $read_name = "Manatee"."_".$counter;
	  print OUTPUT "\@$read_name\n";
	  print OUTPUT "$sequence\n";
	  print OUTPUT "+$read_name\n";
	  print OUTPUT "$quality\n";
	  $quality = 'A' x length($sequence);
	  $read_tags{$read_name} = $collapsed_reads{$sequence}{$quality};
	  $counter++;
      }
    }    
  }else{ # Fasta file
      my $line_nr = 1;
      my $counter = 1; 
      while(<INPUT>){
	chomp $_;
	$_ =~ s/^\s+|\s+$//g;
	if($line_nr % 2 eq 0){
	  if(exists $collapsed_reads{$_}){
	    $collapsed_reads{$_}++;
	  }else{
	    $collapsed_reads{$_} = 1;
	  }
	}
	$line_nr++;
      }
      foreach my $sequence (keys %{collapsed_reads}){
	  my $read_name = "Manatee"."_".$counter;
	  print OUTPUT ">$read_name\n";
	  print OUTPUT "$sequence\n";
	  $read_tags{$read_name} = $collapsed_reads{$sequence};#Nr of identical nucleotide sequences.
	  $counter++;
      }
 }
  close INPUT;
  close OUTPUT;
}

#Write estimated transcript counts to output file.
sub write_expressions {

  open(my $TRANSCRIPTS_COUNTS, ">", $transcripts_counts);
  my %tmp;
  my $i = 0;
  
  foreach my $transcript (sort keys %{transcripts}){  

    my @arr1 = split($ALTERNATIVE_TRANS_SEPARATOR, $transcript);
    my @arr2 = split($SEPARATOR, $arr1[0]);
    my $chromosome = $arr2[0];
    my $strand = $arr2[1];
    my $id = $arr2[2];
    my $biotype = $arr2[3];
    my $first_transcript = $arr2[2];
    my $start_pos = $arr2[5];
    my $stop_pos = $arr2[6];
    my $sum = 0;
    my $unique = 0;

    foreach my $type (sort keys %{$transcripts{$transcript}}){
      if($type eq $unique_type){
	$unique = $transcripts{$transcript}{$type};
	$sum += $transcripts{$transcript}{$type};
      }else{
	$sum += $transcripts{$transcript}{$type};
      }
    }
   
    shift @arr1;
    my $all_transcripts = $EMPTY; #Add the first transcript. 
    foreach my $element (@arr1){
      my @arr = split($SEPARATOR, $element);
        if($all_transcripts !~ /$arr[2]/ and $arr[2] ne $first_transcript){ #Check for double transcripts.
	  if($all_transcripts eq $EMPTY){
	    $all_transcripts = $arr[2]
	  }else{
	    $all_transcripts = $all_transcripts.$ALTERNATIVE_TRANS_SEPARATOR_FILE.$arr[2];
	  }	  
	}
    }
    
    my $rpm;
    if($mapped_reads > 0){
      $rpm = ($sum*(10**6))/($mapped_reads); #Reads per million calculation.
    }else{
      $rpm = $NA;
    }
    
    $tmp{$first_transcript}{$all_transcripts}{'sum'} += $sum;
    $tmp{$first_transcript}{$all_transcripts}{'rpm'} += $rpm;
    $tmp{$first_transcript}{$all_transcripts}{'unique'} += $unique;
    #The biotype of the first transcript
    $tmp{$first_transcript}{$all_transcripts}{'biotype'} = $biotype;
    
  }
  
  my %common;
  #Extract common with the highest read counts.
  foreach my $first_transcript (sort keys %{tmp}){
    my %alternative = ();
    foreach my $all_transcripts (keys %{$tmp{$first_transcript}}){
    
        $alternative{$all_transcripts}{'sum'} = $tmp{$first_transcript}{$all_transcripts}{'sum'};
        $alternative{$all_transcripts}{'rpm'} = $tmp{$first_transcript}{$all_transcripts}{'rpm'};
        $alternative{$all_transcripts}{'unique'} = $tmp{$first_transcript}{$all_transcripts}{'unique'};
        $alternative{$all_transcripts}{'biotype'} = $tmp{$first_transcript}{$all_transcripts}{'biotype'};
        
    }
    
    my $max_reads = 0;
    my $sum_reads = 0;
    my $sum_unique = 0;
    my $sum_rpm = 0;
    my $biotype;
    my $keep_trans = $EMPTY;
    foreach my $all_transcripts (keys %{alternative}){
      if($max_reads <= $alternative{$all_transcripts}{'sum'}){
	$keep_trans = $all_transcripts;
      }
      $sum_reads  += $alternative{$all_transcripts}{'sum'};
      $sum_rpm    += $alternative{$all_transcripts}{'rpm'};
      $sum_unique += $alternative{$all_transcripts}{'unique'};
      $biotype     = $alternative{$all_transcripts}{'biotype'};
    }
    $common{$first_transcript}{$keep_trans}{'sum'} = $sum_reads;
    $common{$first_transcript}{$keep_trans}{'rpm'} = $sum_rpm;
    $common{$first_transcript}{$keep_trans}{'unique'} = $sum_unique;
    $common{$first_transcript}{$keep_trans}{'biotype'} = $biotype;
  }
 
  print $TRANSCRIPTS_COUNTS "Transcript Name\tBiotype\tCount\tRPM\tUnique Reads\tOther possible transcripts\n";

  
  foreach my $gene_id (sort keys %{gtf_simplified}){
    if(exists $common{$gene_id}){
      foreach my $keep_trans (keys %{$common{$gene_id}}){
  
	my $sum = $common{$gene_id}{$keep_trans}{'sum'};
	my $rpm = $common{$gene_id}{$keep_trans}{'rpm'};
	my $unique = $common{$gene_id}{$keep_trans}{'unique'};
	my $biotype = $common{$gene_id}{$keep_trans}{'biotype'};
	
	print $TRANSCRIPTS_COUNTS "$gene_id\t$biotype\t";
	print $TRANSCRIPTS_COUNTS "$sum\t$rpm\t$unique\t$keep_trans\n";
      
      }
    }else{
      print $TRANSCRIPTS_COUNTS "$gene_id\t$gtf_simplified{$gene_id}\t";
      print $TRANSCRIPTS_COUNTS "0\t0\t0\n";
    }
  }
}

#Remove all the temp files generated during the execution.
sub clean {
 
	 #Remove all temp files.
	 my $files_to_del_str = `ls $output_path`;
	 my @files_to_del = split('\n',$files_to_del_str);
	 for my $file (@files_to_del){
	  $file =~ s/^\s+|\s+$//g; # Removing leading and trailing white spaces.
	  if($file !~ /Manatee_isomirs.tsv|Manatee_counts.tsv|Manatee_clusters.tsv/){
	     my $ftr = $output_path.$file;
	    `rm $ftr`;
	  }
	 }
	 #Remove clusters file if empty.
	 my @nr_lines = `cat $clusters_output | wc -l`;
	 $nr_lines[0] =~ s/\n+$//g;
	 if($nr_lines[0] eq 1){
	  if(-f $clusters_output){
	    `rm $clusters_output`;
	  }
	 }
	 
 }
 
 sub remove_output {
 
	rmdir $output_path;
 
 }